#+TITLE: Simple Org Wiki 만들기
#+DATE: <2020-11-02 Mon>


* DONE 의도
  CLOSED: [2020-11-02 Mon 14:28]
  1) org 링크를 만드는 것이 더 쉬웠으면 좋겠다고 생각했다.
     1) org link만으로 만족하고 쓸만한 위키이니까.
  2) 문서들을 조직하고 정리하는 방법이 더 느슨했으면 했다.
     1) 마인드맵, 위키, 카테고리 방식과 같은 직접 연결된 문서이나
        디렉토리 계층과 같은, 1:n 구조만이 아니라,
     2) 그냥 각 문서가 직접 링크나 언급이 아예 없어도, 같은 "태그"를
        갖는 것만으로 연관이 생겼으면 좋겠다고 생각했다.

** 어째서
   책을 쓰든, 오랬동안 진행되는 회사를 만들 프로젝트를 하건, 또 그런
   와중에 계속해서 생각나는 아이디어들이 있든, 결국엔 knowledge base을
   제대로 만들어야 한다는 생각이 들었다.

   책을 쓰기 위해서, 계속해서 글을 적어놓고, 그 글들을 조직하기
   위해서는 어느 정도 다시 찾아볼 수 있을 방식이 있어야 한다.

   진행되는 프로젝트에 대해서도 마찬가지. 매일 매일 어떤 상황이고
   무엇을 해야 하는지를 각 프로젝트별로 정리하고 기록해 놓았는데, 큰
   흐름에서 정리할 방법이 없었어서.

   계속해서 아이디어들이 떠오르는데, 메모를 하고 노트에 적어놓거나
   하고 그냥 놓치는 것 같아서.

** 대안들에 대한 생각   
   1) org-roam 등은 너무 사용하지 않는 기능이 많은 것 같아서.
   2) hyperbole은 도대체 뭘 하려고 하는지, 어떻게 설정하고 쓰는지 알기
      어려워서.


* DONE (AA) 링크 만들기, 링크 할 파일을 검색하기                    :feature:
  CLOSED: [2020-11-04 Wed 02:52]
  1) 하위디렉토리 검색.
     1) projectile, fuzzy matching.
  2) 링크의 이름?
     1) 선택한 transient 영역을 사용.
     2) transient 없으면, ~#+TITLE:~ 이나 파일이름으로.
  3) 이거 딱히 당장 없어도 그냥 C-c C-l으로 살만할 것 같다.

* TODO (A) 특정 tag, tag-set에 대해 속하는 문서 검색 리스팅하기     :feature:
  1) ex: ~#+TAGS[]: a b c~
  2) 리스팅 버퍼, 정렬기준변경/재정렬, 타이틀 표시, 열기 링크.

* TODO (B) tag-set 리스팅하기                                       :feature:
  1) 하위 디렉토리의 모든 문서에서 tag셋 모아서 리스팅.
  2) 태그, 속하는 문서 카운팅, 정렬기준변경/재정렬.
  3) org-ql으로 검색, sqlite3이나 dbm등으로 홈디렉토리이나
     ~$HOME/.emacs.d/~ 에 캐싱.

* TODO (C) 문서에 태그 추가, 삭제하기                               :feature:
  1) "(B) tag-set 리스팅하기"의 목록을 구해서(캐싱하거나).
  2) fuzzy matching으로 추가, 삭제.



* DONE sqlite3 api? dbm?
  CLOSED: [2020-11-02 Mon 14:28]
  1) https://github.com/pekingduck/emacs-sqlite3-api
     1) org-roam에서도 이걸 썼었던 것 같다.
     2) c api을 wrapper을 빌드해서 설치하는 듯.
     3) sqlite3 / melpa.
  2) https://github.com/cireu/emacsql-sqlite3
     1) 이건 sqlite3 cli을 쓰는 것 같은데,
     2) 조금 뭔지 closql 같은 것을 써서 모르겠어서 무시하기로.
  3) 다른 dbm이나 tokyo-cabinet 같은 것들에 대해서는 elpa, melpa에서
     패키지가 없으니 없다고 생각하자.


* DONE org-link의 protocol을 추가하기? -- org-wiki-server이 가능해지도록?
  CLOSED: [2020-11-02 Mon 14:19]
  1) <2020-11-02 Mon> 아직은 확장할 방법을 잘 모르겠는데.
  2) 그리고 혹여 org-wiki-server을 만들더라도 그냥 파일/디렉토리에
     org파일을 모아 놓은 것보다 여러모로 부자연스러울 것 같아서.
     1) 링크를 선택하기 복잡할 것 같다. -- 추가적인 해킹.
     2) 링크를 열기 -- 마찬가지.
     3) Git등으로 간단히 sync와 resolving-conflict이 가능한 것에
        비해서 더 복잡해질 동시성 모델

* DONE ~#+TAGS[]:~ 을 org-ql으로 읽기? 쓰기? [0/3]                 :question:
  CLOSED: [2020-11-03 Tue 19:28]
  1) [ ] 태그 목록을 읽을 수 있어야 하고.
  2) [ ] (태그 목록이 없다면) org파일에 추가 할 수 있어야 하고.
  3) [ ] (있다면) 그 목록에 태그를 추가/삭제 할 수 있어야.

** TODO org-ql? org-ml! [0/2]
   1) org-ql으로 얻을 수 있을 것 같았는데,
      1) 얻기는 얻으나, 별로.
   2) 그래서 org-ml으로 다시 시도.
      #+begin_src emacs-lisp
        (org-ml-parse-section-at -1)

        ;;; OR
        (org-ml-parse-this-toplevel-section)

         (section (:begin 1 :end 106 :contents-begin 1 :contents-end 104 :post-blank 2 :post-affiliated 1 :parent nil)
                  (keyword (:key "TITLE" :value "TITLE_THIS"
                                 :begin 1 :end 21 :post-blank 0 :post-affiliated 1 :parent #0))
                  (keyword (:key "DATE" :value "2020-10-20 00:00:00+09:00"
                                 :begin 21 :end 55 :post-blank 0 :post-affiliated 21 :parent #0))
                  (keyword (:key "CATEGORIES[]" :value "a-category"
                                 :begin 55 :end 82 :post-blank 0 :post-affiliated 55 :parent #0))
                  (keyword (:key "TAGS[]" :value "tag_a tag_b"
                                 :begin 82 :end 104 :post-blank 0 :post-affiliated 82 :parent #0)))
      #+end_src

      1) https://github.com/ndwarshuis/org-ml

   3) [ ] 이제 이 list에서 {:key == "TAGS[]"} 얻기는?
      #+begin_src emacs-lisp
        (cl-remove-if-not (lambda (node)
                            (and (eq 'keyword (car node))
                                 (equal "TAGS[]" (plist-get (cadr node) :key))))
                          (->> (org-ml-parse-section-at -1)
                               (org-ml-get-children)))
      #+end_src

   4) [ ] 그리고 {:key == ...} 수정하기는?




* DONE Perl way <2020-11-03 Tue>
  CLOSED: [2020-11-03 Tue 15:15]
  #+begin_src perl
    # find in file


    perl -ne 'print $1 if m/^\#\+tags\[\]\:(.+)$/i'

        # perl -ne 'print if m/whatever/' file

        if ( !open(LOGFILE, "<myfile.log") ) 
        {
        print "ERROR: failed to open myfile.log\n";}
        else {   
        while (<LOGFILE>){
        if ($_ =~ /pattern/)
            {    print "found\n";
                 break;
             }
        }   
        close (LOGFILE);
        }

        # change file inplace .. Open the file in update mode ("+<"), read the
        # whole file into an array of lines, change the array, then rewrite
        # the file and truncate it to its current seek pointer.

        open(FH, "+< FILE")                 or die "Opening: $!";
        @ARRAY = <FH>;
        # change ARRAY here
        seek(FH,0,0)                        or die "Seeking: $!";
        print FH @ARRAY                     or die "Printing: $!";
        truncate(FH,tell(FH))               or die "Truncating: $!";
        close(FH)                           or die "Closing: $!";

        # 2nd
        use strict;
        use warnings;

        our $^I = '.bak';

        while ( my $file = glob '*.csv' ) {

          print "Processing $file\n";

          our @ARGV = ($file);

          while ( <ARGV> ) {
             tr/a-z/A-Z/;
             print;
          }
        }
  #+end_src



* DONE ~tags[]~ 수정하기 방법 [3/3]
  CLOSED: [2020-11-03 Tue 19:28]
  1) 우선 이미 존재 하는 tags을 모은다.
  2) 파일에서 ~#+tags[]: ...~ 부분을 생략하고 복사한다. -> tmp_a
     
  3) tmp_a에서 마지막 ~#+..~ 라인을 찾는다. -> line_last_sec_kw
     1) --- 하나도 없다면, 0라인부터.
        
  4) line_last_sec_kw 다음에 새로운 ~#+tags[]: ...~ 을 생성하여
     삽입한다. -> (tmp_a -> tmp_b)
  5) tmp_b을 원래의 파일으로 교체한다.
  6) tmp_a, tmp_b을 정리한다.

** DONE (1) 파일에서 tags 모으기
   CLOSED: [2020-11-03 Tue 15:18]
   - [[file:search-tags.pl]]

** DONE (2) tags 제외하고 복사하기
   CLOSED: [2020-11-03 Tue 15:22]
   - [[file:exclude-tags.pl]]

** DONE (3) 마지막 ~#+...:~ 라인을 찾아 원하는 tags을 삽입하기 [2/2]
   CLOSED: [2020-11-03 Tue 19:28]
   1) [X] 파일에서 마지막 kw행 찾기: [[file:last-seckw-line.pl]]
   2) [X] 특정 행번호에 tags 삽입하기: [[file:insert-tags.pl]]



* DONE "태그에 속한 파일 검색"의 결과 보기?
  CLOSED: [2020-11-04 Wed 01:37]

  1) <2020-11-04 Wed> 그냥 perl script을 실행한 것을 org-mode으로
     보여주면 되지 않을까? 
     1) 링크도 바로 되고.

  2) PoC: [[file:gen-org-buf.el]]
     1) 그냥 buffer 만들고 내용 쓰고, org-mode으로 채워 넣으면
        끝나는구나. 너무 간단하다.

  3) PoC: [[file:gen-file-btn.el]]
     1) 이렇게 그냥 RET 누르면 이동하는 button / "clickable text"을
        이용하는 방법도 있음.
     2) 이 방법은 orgmode 없어도 동작하겠지.

* TODO Perl / Tags CLI [1/4]
  1) <2020-11-03 Tue>
  2) [ ] ~add $FILE $TAG_A $TAG_B ...~
  3) [ ] ~del $FILE $TAG_A $TAG_B ...~
  4) [ ] ~list $FILE~
  5) [X] ~find_has_all $DIR $TAG_A $TAG_B ...~
     - <2020-11-04 Wed> 일단 이것만 완성되어도 쓸만해지니까.
       - 완성: [[file:org.pl]]
  6) temp-file, move-file etc.
     #+begin_src cperl
       use File::Temp qw/tempfile/;

       my ($fh, $filename) = tempfile( $template, TMPDIR => 1 );

       binmode( $fh, ":utf8" );

       print($fh $stufftowrite); # note the lack of comma

       # ----------------------------------------------------------------------

       use File::Copy qw/move/;

       # ----------------------------------------------------------------------

       unlink($FILENAME) or die "Can't delete $FILENAME: $!\n";

       # ----------------------------------------------------------------------

       use File::Find;

       find(\&print_name_if_dir, ".");

       sub print_name_if_dir
       {
           print if -d;
       }
     #+end_src
    

* <2020-11-04 Wed> overkill 없이 -- (A) 태그에 속한 파일만 검색하기 
  1) 태그 목록을 나열하거나, 태그를 추가/삭제 하는 것들은 essential한
     작업들이 아니다.
     - 추가/삭제는 직접 손으로 열어서 편집해도 되고,
     - 태그 목록을 전부 나열하는 것은 당장은 필요 없지 않을까.



* DONE Elisp + Org.pl --> <2020-11-04 Wed> 검색 만들기 [2/2]
  CLOSED: [2020-11-04 Wed 03:25]
  1) Perl script 찾을 경로? 
    #+begin_src emacs-lisp
    ;;; TODO Function: symbol-file symbol &optional type

    (defvar foo-directory (file-name-directory load-file-name)
      "*Directory for data files belonging to package \`foo'.")
    #+end_src

     1) 아니면, 그냥 PATH에서 찾자.

  2) [X] elisp: prompt tags
     #+begin_src emacs-lisp
       (message "==> [%s]" (read-string "Enter tags: "))
     #+end_src

  3) [X] elisp: base-dir 경로 선택하기
     #+begin_src emacs-lisp
       (message "Dir: %s" (read-directory-name "Dir? "))
     #+end_src

  4) 완성 [[file:org-more.el]]


* TODO README 쓰기
